{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction About Hyacinth Welcome to the Hyacinth docs! Hyacinth is a hybrid imperative-functional programming language with a static, nominal type system. Hyacinth is compiled to a custom bytecode format, and run by the Hyacinth bytecode VM. The design of Hyacinth is inspired by several languages including Typescipt, Haskell, and C#. Hyacinth is an in-progress personal project of Robin Gieseking. Hyacinth is not ready or intended for any production use, and may have backwards-incompatible changes at any time. This project is mostly a vehicle for me to learn more about compilers and programming language theory. But, if you are interested in Hyacinth, feel free to check it out and play around with it a little. The Hyacinth repository, which includes the compiler, VM, docs, and examples is located at https://github.com/avian-lovelace/hyacinth About Hyacinth Docs This documentation explains how to install and run the Hyacinth compiler and features of the Hyacinth language. It is primarily written for my own future reference, but should be generally understandable for most people familiar with at least one other programming language. Acknowledgments The following resources were very helpful to me when working on this project. A big thanks to their authors for making them available for free online! Crafting Interpreters by Robert Nystrom - This book was instrumental when starting to implementing Hyacinth. Crafting Interpreters taught me how to structure a compiler, how a stack VM works, how to write a garbage collector, and was generally influential on most parts of this project. Bidirectional Typing Rules: A Tutorial by David Raymond Christiansen - This paper and the accompanying talk were what really helped me understand bidirectional type checking. Parser Combinators: a Walkthrough by Antoine Leblanc - This article was a great resource in understanding how parser combinators work and how to use them effectively.","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#about-hyacinth","text":"Welcome to the Hyacinth docs! Hyacinth is a hybrid imperative-functional programming language with a static, nominal type system. Hyacinth is compiled to a custom bytecode format, and run by the Hyacinth bytecode VM. The design of Hyacinth is inspired by several languages including Typescipt, Haskell, and C#. Hyacinth is an in-progress personal project of Robin Gieseking. Hyacinth is not ready or intended for any production use, and may have backwards-incompatible changes at any time. This project is mostly a vehicle for me to learn more about compilers and programming language theory. But, if you are interested in Hyacinth, feel free to check it out and play around with it a little. The Hyacinth repository, which includes the compiler, VM, docs, and examples is located at https://github.com/avian-lovelace/hyacinth","title":"About Hyacinth"},{"location":"#about-hyacinth-docs","text":"This documentation explains how to install and run the Hyacinth compiler and features of the Hyacinth language. It is primarily written for my own future reference, but should be generally understandable for most people familiar with at least one other programming language.","title":"About Hyacinth Docs"},{"location":"#acknowledgments","text":"The following resources were very helpful to me when working on this project. A big thanks to their authors for making them available for free online! Crafting Interpreters by Robert Nystrom - This book was instrumental when starting to implementing Hyacinth. Crafting Interpreters taught me how to structure a compiler, how a stack VM works, how to write a garbage collector, and was generally influential on most parts of this project. Bidirectional Typing Rules: A Tutorial by David Raymond Christiansen - This paper and the accompanying talk were what really helped me understand bidirectional type checking. Parser Combinators: a Walkthrough by Antoine Leblanc - This article was a great resource in understanding how parser combinators work and how to use them effectively.","title":"Acknowledgments"},{"location":"control_flow/","text":"Control Flow Block Expressions Block expressions group together a sequence of statements. When a block expression is evaluated, the statements in the block are evaluated in order, then the block expression evaluates to nil . printLine\u27e8Nil\u27e9[{ printLine\u27e8String\u27e9[\"This happens first\"]; }]; // Outputs: // This happens first // nil If expressions If expressions allow for code branching depending on a condition. They can be used as part of expressions for their value. let a = 5; let b = 3; let max = if a > b then a else b; max>>printLine[]; // Outputs: // 5 If expressions can also be used for the side-effects of their branches, often in combination with block expressions. if 1 + 1 == 2 then { \"1 + 1 is 2\">>printLine[]; } else { \"1 + 1 is not 2\">>printLine[]; }; // Outputs: // 1 + 1 is 2 When the true branch of an if expressions has type Nil , the false branch may be omitted. if !(true && false) then { \"evaluated to true\">>printLine[]; }; // Outputs: // evaluated to true While loop statements While loop statements evaluate their body expression repeatedly until their condition is false. let mut a = 1; while a < 10 loop { a>>printLine[]; mut a = a * 3; }; // Outputs: // 1 // 3 // 9","title":"Control Flow"},{"location":"control_flow/#control-flow","text":"","title":"Control Flow"},{"location":"control_flow/#block-expressions","text":"Block expressions group together a sequence of statements. When a block expression is evaluated, the statements in the block are evaluated in order, then the block expression evaluates to nil . printLine\u27e8Nil\u27e9[{ printLine\u27e8String\u27e9[\"This happens first\"]; }]; // Outputs: // This happens first // nil","title":"Block Expressions"},{"location":"control_flow/#if-expressions","text":"If expressions allow for code branching depending on a condition. They can be used as part of expressions for their value. let a = 5; let b = 3; let max = if a > b then a else b; max>>printLine[]; // Outputs: // 5 If expressions can also be used for the side-effects of their branches, often in combination with block expressions. if 1 + 1 == 2 then { \"1 + 1 is 2\">>printLine[]; } else { \"1 + 1 is not 2\">>printLine[]; }; // Outputs: // 1 + 1 is 2 When the true branch of an if expressions has type Nil , the false branch may be omitted. if !(true && false) then { \"evaluated to true\">>printLine[]; }; // Outputs: // evaluated to true","title":"If expressions"},{"location":"control_flow/#while-loop-statements","text":"While loop statements evaluate their body expression repeatedly until their condition is false. let mut a = 1; while a < 10 loop { a>>printLine[]; mut a = a * 3; }; // Outputs: // 1 // 3 // 9","title":"While loop statements"},{"location":"core_concepts/","text":"Core Concepts Statements A Hyacinth program consists of a sequence of statements, separated by semicolons. We've already seen and example of an expression statement in Running the compiler that evaluates an expression for its side effects. Other types of statement will be covered later in the docs. Values Hyacinth has six core value types: Int - A 32-bit signed integer Float - A 64-bit floating point number String - UTF-8 encoded text Char - A single UTF-8 encoded Unicode code point Bool - A boolean value, True or False Nil - A type with a single possible value, nil Each of the core value types can be created via literal expressions and output via print statements. printLine\u27e8Int\u27e9[123]; printLine\u27e8Float\u27e9[3.14]; printLine\u27e8Char\u27e9['a']; printLine\u27e8String\u27e9[\"Hyacinth\"]; printLine\u27e8Bool\u27e9[true]; printLine\u27e8Nil\u27e9[nil]; // Outputs: // 123 // 3.14 // a // Hyacinth // true // nil Operators Hyacinth includes various operators that act on these core value types: Arithmetic: + , - , * , / , % Boolean: && , || , ! Equality: == , != Comparison: > , < , >= , >= String concatenation: + printLine\u27e8Int\u27e9[1 + 2 * 3]; printLine\u27e8Bool\u27e9[15 % 4 == 3 && 6 > -13]; printLine\u27e8String\u27e9[\"concatenating\" + ' ' + \"strings\"]; // Outputs: // 7 // true // concatenating strings Comments In Hyacinth, a double forward slash ( // ) makes the rest of the line into a comment which is not evaluated as code. // This text is not evaluated \"Hello, World!\">>printLine[]; // This text is not evaluated either // Outputs: // Hello, World!","title":"Core Concepts"},{"location":"core_concepts/#core-concepts","text":"","title":"Core Concepts"},{"location":"core_concepts/#statements","text":"A Hyacinth program consists of a sequence of statements, separated by semicolons. We've already seen and example of an expression statement in Running the compiler that evaluates an expression for its side effects. Other types of statement will be covered later in the docs.","title":"Statements"},{"location":"core_concepts/#values","text":"Hyacinth has six core value types: Int - A 32-bit signed integer Float - A 64-bit floating point number String - UTF-8 encoded text Char - A single UTF-8 encoded Unicode code point Bool - A boolean value, True or False Nil - A type with a single possible value, nil Each of the core value types can be created via literal expressions and output via print statements. printLine\u27e8Int\u27e9[123]; printLine\u27e8Float\u27e9[3.14]; printLine\u27e8Char\u27e9['a']; printLine\u27e8String\u27e9[\"Hyacinth\"]; printLine\u27e8Bool\u27e9[true]; printLine\u27e8Nil\u27e9[nil]; // Outputs: // 123 // 3.14 // a // Hyacinth // true // nil","title":"Values"},{"location":"core_concepts/#operators","text":"Hyacinth includes various operators that act on these core value types: Arithmetic: + , - , * , / , % Boolean: && , || , ! Equality: == , != Comparison: > , < , >= , >= String concatenation: + printLine\u27e8Int\u27e9[1 + 2 * 3]; printLine\u27e8Bool\u27e9[15 % 4 == 3 && 6 > -13]; printLine\u27e8String\u27e9[\"concatenating\" + ' ' + \"strings\"]; // Outputs: // 7 // true // concatenating strings","title":"Operators"},{"location":"core_concepts/#comments","text":"In Hyacinth, a double forward slash ( // ) makes the rest of the line into a comment which is not evaluated as code. // This text is not evaluated \"Hello, World!\">>printLine[]; // This text is not evaluated either // Outputs: // Hello, World!","title":"Comments"},{"location":"functions/","text":"Functions In Hyacinth, function declarations statements can be used to define functions. func sumSquare = [x: Int, y: Int]: Int -> x * x + y * y; sumSquare[3, 4]>>printLine[]; // Outputs: // 25 Functions defined via function declaration statements may be referenced earlier in a scope than their definition. printFoo[]; func printFoo = []: Nil -> { \"Foo\">>printLine[]; } // Outputs: // Foo They also may be self-recursive or mutually recursive. func triangle = [n: Int]: Int -> if n <= 0 then 0 else n + triangle[n-1]; triangle[5]>>printLine[]; // Outputs: // 15 Return Statements Return statements can be used to exit out of a function immediately and return a value. func myFunc = [x: Float]: Float -> { if x <= 0.0 then { return -x * 0.5; }; \"input was positive\">>printLine[]; return x * 2.0; }; myFunc[-1.2]>>printLine[]; myFunc[1.2]>>printLine[]; // Outputs: // 0.6 // input was positive // 2.4 Note that in the previous example, the body of myFunc is a block, which has type Nil , but myFunc has return type Float . In Hyacinth, if the body of a function is a block, and the compiler can determine that running the function will always execute a return statement, then the return type of the function is based only on the types of the values in the return statements. Return statements can be used without a return value to return nil . func countdown = [x: Int]: Nil -> { if x <= 0 then { \"Happy New Year!\">>printLine[]; return; }; x>>printLine[]; countdown[x - 1]; }; countdown[3]; // Outputs: // 3 // 2 // 1 // Happy New Year! Function Expressions Functions can also be created inline with function expressions. applyTwice[ // Function expression [x] -> x * 3, 1 ]>>printLine[]; func applyTwice = [f: [Int] -> Int, x: Int]: Int -> f[f[x]]; // Outputs: // 9 Function expressions can be combined with variables to get something like a function declaration statement. let sumSquare = [x: Int, y: Int]: Int -> x * x + y * y; sumSquare[3, 4]>>printLine[]; // Outputs: // 25 However, since variables can only be referenced after their declaration, this does not (straightforwardly) permit self-recursive and mutually recursive functions. Variable Capturing Functions can capture variables. That is, the body of a function can reference an identifier defined in an enclosing scope. let message = \"Have a nice day :)\"; let printMessage = []: Nil -> { message>>printLine[]; }; printMessage[]; // Outputs: // Have a nice day :) In Hyacinth, variables are captured statically, and if a captured variable is mutated after capture, the captured value will not change. For function expressions, variables are captured when the function is defined. let mut x = 1; let printCapturedValue = []: Nil -> { x>>printLine[]; }; mut x = 2; x>>printLine[]; printCapturedValue[]; // Outputs: // 2 // 1 For functions defined by a function declaration statement, variables are instead captured at the point where the function is referenced. let mut x = 1; let firstReference = printCapturedValue; mut x = 2; printCapturedValue[]; mut x = 3; printLine\u27e8Int\u27e9[x]; firstReference[]; func printCapturedValue = []: Nil -> { x>>printLine[]; }; // Outputs: // 2 // 3 // 1 Type Parameters Functions defined by a function declaration statement may take type parameters. If a function has type parameters, type arguments can be provided when the function is referenced. func apply = \u27e8T, V\u27e9 => [f: [T] -> V, x: T]: V -> f[x]; apply\u27e8Int, Bool\u27e9[[x] -> x > 0, 5]>>printLine[]; // Outputs: // true In some cases, a function's type arguments can be inferred from known type information by the compiler, and the type arguments can be omitted. func printAndReturn = \u27e8T\u27e9 => [x: T]: T -> { x>>printLine[]; return x; }; let foo: Int = printAndReturn[3]; // Outputs: // 3 Built-in Functions Hyacinth includes a number of built-in functions that give access to otherwise unavailable functionality. Below are some of the built-in functions provided by Hyacinth. Some more built-in functions are covered in the list documentation . print: \u27e8T\u27e9 => [T] -> Nil - Outputs a value to the standard output printLine: \u27e8T\u27e9 => [T] -> Nil - Outputs a value to the standard output with a line break after readLine: [] -> String - Reads a line from the standard input and returns it as a string Method Call Operator The method call operator ( >> ) is an alternate syntax for calling functions. func myFunc = [x: String, y: String]: Nil -> { (\"The first parameter is \" + x)>>printLine[]; (\"The second parameter is \" + y)>>printLine[]; }; let foo = \"foo\"; let bar = \"bar\"; foo>>myFunc[bar]; // Outputs: // The first parameter is foo // The second parameter is bar Unlike some other languages, the method call operator does not enable dynamic dispatch; it is equivalent at run-time to a normal function call. However, using method call syntax can help to write cleaner code in a couple ways. Method calls can be chained, passing the output of one function as the first parameter of the next. func double = [x: Int]: Int -> 2 * x; func addOne = [x: Int]: Int -> x + 1; 3>>double[]>>addOne[]>>double[]>>printLine[]; // Outputs: // 14 With method call syntax, the compiler uses the type of the first parameter when inferring a function's type arguments. This in some cases allows omitting a function's type arguments when a normal function call would require passing them explicitly. func printIfPositive = \u27e8T\u27e9 => [printValue: T, switchValue: Int]: Nil -> if switchValue > 0 then { printValue>>printLine[]; }; // With normal function call syntax, explicit type arguments are required printIfPositive\u27e8String\u27e9[\"foo\", 5]; // With method call syntax, type arguments can be inferred \"foo\">>printIfPositive[5]; // Outputs: // foo // foo","title":"Functions"},{"location":"functions/#functions","text":"In Hyacinth, function declarations statements can be used to define functions. func sumSquare = [x: Int, y: Int]: Int -> x * x + y * y; sumSquare[3, 4]>>printLine[]; // Outputs: // 25 Functions defined via function declaration statements may be referenced earlier in a scope than their definition. printFoo[]; func printFoo = []: Nil -> { \"Foo\">>printLine[]; } // Outputs: // Foo They also may be self-recursive or mutually recursive. func triangle = [n: Int]: Int -> if n <= 0 then 0 else n + triangle[n-1]; triangle[5]>>printLine[]; // Outputs: // 15","title":"Functions"},{"location":"functions/#return-statements","text":"Return statements can be used to exit out of a function immediately and return a value. func myFunc = [x: Float]: Float -> { if x <= 0.0 then { return -x * 0.5; }; \"input was positive\">>printLine[]; return x * 2.0; }; myFunc[-1.2]>>printLine[]; myFunc[1.2]>>printLine[]; // Outputs: // 0.6 // input was positive // 2.4 Note that in the previous example, the body of myFunc is a block, which has type Nil , but myFunc has return type Float . In Hyacinth, if the body of a function is a block, and the compiler can determine that running the function will always execute a return statement, then the return type of the function is based only on the types of the values in the return statements. Return statements can be used without a return value to return nil . func countdown = [x: Int]: Nil -> { if x <= 0 then { \"Happy New Year!\">>printLine[]; return; }; x>>printLine[]; countdown[x - 1]; }; countdown[3]; // Outputs: // 3 // 2 // 1 // Happy New Year!","title":"Return Statements"},{"location":"functions/#function-expressions","text":"Functions can also be created inline with function expressions. applyTwice[ // Function expression [x] -> x * 3, 1 ]>>printLine[]; func applyTwice = [f: [Int] -> Int, x: Int]: Int -> f[f[x]]; // Outputs: // 9 Function expressions can be combined with variables to get something like a function declaration statement. let sumSquare = [x: Int, y: Int]: Int -> x * x + y * y; sumSquare[3, 4]>>printLine[]; // Outputs: // 25 However, since variables can only be referenced after their declaration, this does not (straightforwardly) permit self-recursive and mutually recursive functions.","title":"Function Expressions"},{"location":"functions/#variable-capturing","text":"Functions can capture variables. That is, the body of a function can reference an identifier defined in an enclosing scope. let message = \"Have a nice day :)\"; let printMessage = []: Nil -> { message>>printLine[]; }; printMessage[]; // Outputs: // Have a nice day :) In Hyacinth, variables are captured statically, and if a captured variable is mutated after capture, the captured value will not change. For function expressions, variables are captured when the function is defined. let mut x = 1; let printCapturedValue = []: Nil -> { x>>printLine[]; }; mut x = 2; x>>printLine[]; printCapturedValue[]; // Outputs: // 2 // 1 For functions defined by a function declaration statement, variables are instead captured at the point where the function is referenced. let mut x = 1; let firstReference = printCapturedValue; mut x = 2; printCapturedValue[]; mut x = 3; printLine\u27e8Int\u27e9[x]; firstReference[]; func printCapturedValue = []: Nil -> { x>>printLine[]; }; // Outputs: // 2 // 3 // 1","title":"Variable Capturing"},{"location":"functions/#type-parameters","text":"Functions defined by a function declaration statement may take type parameters. If a function has type parameters, type arguments can be provided when the function is referenced. func apply = \u27e8T, V\u27e9 => [f: [T] -> V, x: T]: V -> f[x]; apply\u27e8Int, Bool\u27e9[[x] -> x > 0, 5]>>printLine[]; // Outputs: // true In some cases, a function's type arguments can be inferred from known type information by the compiler, and the type arguments can be omitted. func printAndReturn = \u27e8T\u27e9 => [x: T]: T -> { x>>printLine[]; return x; }; let foo: Int = printAndReturn[3]; // Outputs: // 3","title":"Type Parameters"},{"location":"functions/#built-in-functions","text":"Hyacinth includes a number of built-in functions that give access to otherwise unavailable functionality. Below are some of the built-in functions provided by Hyacinth. Some more built-in functions are covered in the list documentation . print: \u27e8T\u27e9 => [T] -> Nil - Outputs a value to the standard output printLine: \u27e8T\u27e9 => [T] -> Nil - Outputs a value to the standard output with a line break after readLine: [] -> String - Reads a line from the standard input and returns it as a string","title":"Built-in Functions"},{"location":"functions/#method-call-operator","text":"The method call operator ( >> ) is an alternate syntax for calling functions. func myFunc = [x: String, y: String]: Nil -> { (\"The first parameter is \" + x)>>printLine[]; (\"The second parameter is \" + y)>>printLine[]; }; let foo = \"foo\"; let bar = \"bar\"; foo>>myFunc[bar]; // Outputs: // The first parameter is foo // The second parameter is bar Unlike some other languages, the method call operator does not enable dynamic dispatch; it is equivalent at run-time to a normal function call. However, using method call syntax can help to write cleaner code in a couple ways. Method calls can be chained, passing the output of one function as the first parameter of the next. func double = [x: Int]: Int -> 2 * x; func addOne = [x: Int]: Int -> x + 1; 3>>double[]>>addOne[]>>double[]>>printLine[]; // Outputs: // 14 With method call syntax, the compiler uses the type of the first parameter when inferring a function's type arguments. This in some cases allows omitting a function's type arguments when a normal function call would require passing them explicitly. func printIfPositive = \u27e8T\u27e9 => [printValue: T, switchValue: Int]: Nil -> if switchValue > 0 then { printValue>>printLine[]; }; // With normal function call syntax, explicit type arguments are required printIfPositive\u27e8String\u27e9[\"foo\", 5]; // With method call syntax, type arguments can be inferred \"foo\">>printIfPositive[5]; // Outputs: // foo // foo","title":"Method Call Operator"},{"location":"getting_started/","text":"Getting Started Installation There are currently no pre-built binaries available for Hyacinth. If you'd like to try out Hyacinth, you can build it from source. Prerequisites To build Hyacinth, you will need the following tools: Stack - The Haskell tool stack The Rust toolchain Building To begin, clone this repository to your computer. git clone https://github.com/avian-lovelace/hyacinth.git cd hyacinth The Hyacinth compiler can be built with Stack. cd compiler stack install The Hyacinth bytecode VM can be build with Cargo. cd ../virtual-machine cargo install --path . Running the compiler Let's write our first Hyacinth program! Create a file named Hello.hyc , and write the following Hyacinth code to it. \"Hello, World!\">>printLine[]; Navigate to the file location in a terminal and run the following command to compile your Hyacinth code file. hyacinth Hello.hyc This should have created a file Hello.hyb in the current directory. This is the compiled Hyacinth bytecode file. To run the program, run the following command. hyacinth-vm Hello.hyb This should print Hello, World! to the command line. You've now installed and run the Hyacinth compiler! For more information on the design of the Hyacinth language, keep reading these docs.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#installation","text":"There are currently no pre-built binaries available for Hyacinth. If you'd like to try out Hyacinth, you can build it from source.","title":"Installation"},{"location":"getting_started/#prerequisites","text":"To build Hyacinth, you will need the following tools: Stack - The Haskell tool stack The Rust toolchain","title":"Prerequisites"},{"location":"getting_started/#building","text":"To begin, clone this repository to your computer. git clone https://github.com/avian-lovelace/hyacinth.git cd hyacinth The Hyacinth compiler can be built with Stack. cd compiler stack install The Hyacinth bytecode VM can be build with Cargo. cd ../virtual-machine cargo install --path .","title":"Building"},{"location":"getting_started/#running-the-compiler","text":"Let's write our first Hyacinth program! Create a file named Hello.hyc , and write the following Hyacinth code to it. \"Hello, World!\">>printLine[]; Navigate to the file location in a terminal and run the following command to compile your Hyacinth code file. hyacinth Hello.hyc This should have created a file Hello.hyb in the current directory. This is the compiled Hyacinth bytecode file. To run the program, run the following command. hyacinth-vm Hello.hyb This should print Hello, World! to the command line. You've now installed and run the Hyacinth compiler! For more information on the design of the Hyacinth language, keep reading these docs.","title":"Running the compiler"},{"location":"lists/","text":"Lists Hyacinth provides a built-in list type that can contain multiple values of the same type. Values can be retrieved from a list with # , the list indexing operator. let myVals = List\u27e8String\u27e9[\"foo\", \"bar\", \"baz\"]; myVals#0>>printLine[]; myVals#2>>printLine[]; // Outputs: // foo // baz The number of elements in a list can be determined using the built-in length function. let myVals = List\u27e8String\u27e9[\"foo\", \"bar\", \"baz\"]; myVals>>length[]>>printLine[] // Outputs: // 3 Mutability Lists are immutable by default, but a list can be declared as mutable with the mut keyword. The values of a mutable list can be modified using mut statements. let myVals = mut List\u27e8Int\u27e9[1, 2, 4, 8, 16, 32]; myVals#5>>printLine[]; mut myVals#5 = 31; myVals#5>>printLine[]; // Outputs: // 32 // 31 Elements can be added or removed from the end of a mutable list using the built-in push and pop functions. func sumLast = [nums: mut List\u27e8Int\u27e9]: mut List\u27e8Int\u27e9 -> { let x = nums>>pop[]; let y = nums>>pop[]; return nums>>push[x + y]; }; let myVals = mut List\u27e8Int\u27e9[1, 3, 5, 7]; myVals>>sumLast[]; myVals#0>>printLine[]; myVals#1>>printLine[]; myVals#2>>printLine[]; // Outputs: // 1 // 3 // 12","title":"Lists"},{"location":"lists/#lists","text":"Hyacinth provides a built-in list type that can contain multiple values of the same type. Values can be retrieved from a list with # , the list indexing operator. let myVals = List\u27e8String\u27e9[\"foo\", \"bar\", \"baz\"]; myVals#0>>printLine[]; myVals#2>>printLine[]; // Outputs: // foo // baz The number of elements in a list can be determined using the built-in length function. let myVals = List\u27e8String\u27e9[\"foo\", \"bar\", \"baz\"]; myVals>>length[]>>printLine[] // Outputs: // 3","title":"Lists"},{"location":"lists/#mutability","text":"Lists are immutable by default, but a list can be declared as mutable with the mut keyword. The values of a mutable list can be modified using mut statements. let myVals = mut List\u27e8Int\u27e9[1, 2, 4, 8, 16, 32]; myVals#5>>printLine[]; mut myVals#5 = 31; myVals#5>>printLine[]; // Outputs: // 32 // 31 Elements can be added or removed from the end of a mutable list using the built-in push and pop functions. func sumLast = [nums: mut List\u27e8Int\u27e9]: mut List\u27e8Int\u27e9 -> { let x = nums>>pop[]; let y = nums>>pop[]; return nums>>push[x + y]; }; let myVals = mut List\u27e8Int\u27e9[1, 3, 5, 7]; myVals>>sumLast[]; myVals#0>>printLine[]; myVals#1>>printLine[]; myVals#2>>printLine[]; // Outputs: // 1 // 3 // 12","title":"Mutability"},{"location":"misc/","text":"Other topics Type Inference As seen in previous examples, in some cases Hyacinth can infer variable types, function parameter types, and type arguments, and type annotations can be omitted. The Hyacinth compiler uses bidirectional type-checking, so information about type expectations flows from the outside in. Unlike some other systems using Hindley-Milner style type inference, Hyacinth does not make any type inferences about identifiers from how they are used. Union-compatible Types If expressions, case expressions, and field access on a record union all create an expression could be one of multiple types. If all branches have the same type, then there's no problem, and the expression has the type of the branches. However, the branches are allowed to have different types only if they meet the following conditions The type of each branch is a record type or record union type If a record type appears in multiple branches, it must have the same type parameters in each branch For example, here's an example of valid code with if expressions. // combo1 has type Foo\u27e8Int\u27e9 | Bar let combo1 = if _condition_ then Foo\u27e8Int\u27e9[value = 5] else Bar // combo2 has type Foo\u27e8Int\u27e9 | Baz let combo2 = if _condition_ then Foo\u27e8Int\u27e9[value = 10] else Baz // combo3 has type Foo\u27e8Int\u27e9 | Bar | Baz let combo3 = if _condition_ then combo1 else combo2 rec Foo = \u27e8T\u27e9 => [value: T]; rec Bar = []; rec Baz = []; And here's an example of valid code with field access on a record union. rec A = [value: X]; rec B = [value: Y]; rec X = []; rec Y = []; let foo: A | B = _value_; // bar has type X | Y let bar = foo.value; The following example is invalid, as one branch is a non-record type. rec Foo = []; let bar = if _condition_ then Foo else 5; And this final example is invalid because branches have different type parameters for the same record. rec Box = \u27e8T\u27e9 => [value: T]; let foo = if _condition_ then Box\u27e8Int\u27e9[value = 3] else Box\u27e8String\u27e9[value = \"foo\"];","title":"Other topics"},{"location":"misc/#other-topics","text":"","title":"Other topics"},{"location":"misc/#type-inference","text":"As seen in previous examples, in some cases Hyacinth can infer variable types, function parameter types, and type arguments, and type annotations can be omitted. The Hyacinth compiler uses bidirectional type-checking, so information about type expectations flows from the outside in. Unlike some other systems using Hindley-Milner style type inference, Hyacinth does not make any type inferences about identifiers from how they are used.","title":"Type Inference"},{"location":"misc/#union-compatible-types","text":"If expressions, case expressions, and field access on a record union all create an expression could be one of multiple types. If all branches have the same type, then there's no problem, and the expression has the type of the branches. However, the branches are allowed to have different types only if they meet the following conditions The type of each branch is a record type or record union type If a record type appears in multiple branches, it must have the same type parameters in each branch For example, here's an example of valid code with if expressions. // combo1 has type Foo\u27e8Int\u27e9 | Bar let combo1 = if _condition_ then Foo\u27e8Int\u27e9[value = 5] else Bar // combo2 has type Foo\u27e8Int\u27e9 | Baz let combo2 = if _condition_ then Foo\u27e8Int\u27e9[value = 10] else Baz // combo3 has type Foo\u27e8Int\u27e9 | Bar | Baz let combo3 = if _condition_ then combo1 else combo2 rec Foo = \u27e8T\u27e9 => [value: T]; rec Bar = []; rec Baz = []; And here's an example of valid code with field access on a record union. rec A = [value: X]; rec B = [value: Y]; rec X = []; rec Y = []; let foo: A | B = _value_; // bar has type X | Y let bar = foo.value; The following example is invalid, as one branch is a non-record type. rec Foo = []; let bar = if _condition_ then Foo else 5; And this final example is invalid because branches have different type parameters for the same record. rec Box = \u27e8T\u27e9 => [value: T]; let foo = if _condition_ then Box\u27e8Int\u27e9[value = 3] else Box\u27e8String\u27e9[value = \"foo\"];","title":"Union-compatible Types"},{"location":"records/","text":"Records In Hyacinth, record types can be defined with a rec statement. rec Dog = [ name: String, age: Int ]; let myPet = Dog[ name = \"Fido\", age = 4, ]; myPet.name>>printLine[]; myPet.age>>printLine[]; // Outputs: // Fido // 4 If a record has no fields, it is instantiated by with just the record name, no brackets. rec Empty = []; let myEmpty = Empty; // not let myEmpty = Empty[]; Record Unions & Case Expressions Record union types let an identifier hold values of multiple possible record types. If all record types in the union share a field with the same name and compatible types , that field value can be used. rec Foo = [ shared: Int, justFoo: String, ]; rec Bar = [ shared: Int, justBar: Bool, ]; let mut x: Foo | Bar = Foo[shared = 1, justFoo = \"foo\"]; x.shared>>printLine[]; mut x = Bar[shared = 2, justBar = true]; x.shared>>printLine[]; // Outputs: // 1 // 2 Case expressions allow for branching based on the record type of a value. rec Foo = [value: String]; rec Bar = []; func printFooBar = [fb: Foo | Bar]: Nil -> case fb of [ Foo: f -> { f.value>>printLine[]; }, Bar: b -> { \"Bar\">>printLine[]; }, ]; printFooBar[Foo[value = \"Foo\"]]; printFooBar[Bar]; // Outputs: // Foo // Bar Type parameters Records may take type parameters rec Pair = \u27e8T\u27e9 => [ first: T, second: T, ]; let point = Pair\u27e8Float\u27e9[first = 1.23, second = 4.5]; point.first>>printLine[]; point.second>>printLine[]; // Outputs: // 1.23 // 4.5 Mutability Records are immutable by default, but a record instance can be made mutable with the mut keyword. The fields of a mutable record can be modified using mut statements. rec Box = [value: Int]; let myBox = mut Box[value = 1]; myBox.value>>printLine[]; mut myBox.value = 2; myBox.value>>printLine[]; // Output // 1 // 2 The mut keyword can also be used in type annotations to require a mutable record. rec Box = [value: Int]; func doubleValue = [box: mut Box]: Nil -> { mut box.value = box.value * 2; }; let myBox = mut Box[value = 4]; myBox.value>>printLine[]; doubleValue[myBox]; myBox.value>>printLine[]; // Outputs: // 4 // 8 Mutability parameters By default, mutability of a record type is propagated to its field types. This is intended to keep simple the common case where a nested record should be deeply mutable or deeply immutable. rec Foo = [a: Bar]; rec Bar = [b: Int]; let mutableFoo = mut Foo[ a = mut Bar[ b = 1 ] ]; mutableFoo.a.b>>printLine[]; mut mutableFoo.a.b = 2; mutableFoo.a.b>>printLine[]; let immutableFooCopy: Foo = mutableFoo; // The following would result in a type error, as immutableFooCopy is deeply immutable // mut immutableFooCopy.a.b = 3; // Outputs: // 1 // 2 However, record field mutability can instead be controlled manually by adding a mutability parameter to a record declaration. If used, the mutability parameter must be the first element of the type parameter list and be prefixed by mut . rec Foo = \u27e8mut M\u27e9 => [ // field a is always immutable a: Bar, // field b is always immutable b: mut Bar, // field c has the same mutability as Foo c: M Bar, ]; rec Bar = [value: Int];","title":"Records"},{"location":"records/#records","text":"In Hyacinth, record types can be defined with a rec statement. rec Dog = [ name: String, age: Int ]; let myPet = Dog[ name = \"Fido\", age = 4, ]; myPet.name>>printLine[]; myPet.age>>printLine[]; // Outputs: // Fido // 4 If a record has no fields, it is instantiated by with just the record name, no brackets. rec Empty = []; let myEmpty = Empty; // not let myEmpty = Empty[];","title":"Records"},{"location":"records/#record-unions-case-expressions","text":"Record union types let an identifier hold values of multiple possible record types. If all record types in the union share a field with the same name and compatible types , that field value can be used. rec Foo = [ shared: Int, justFoo: String, ]; rec Bar = [ shared: Int, justBar: Bool, ]; let mut x: Foo | Bar = Foo[shared = 1, justFoo = \"foo\"]; x.shared>>printLine[]; mut x = Bar[shared = 2, justBar = true]; x.shared>>printLine[]; // Outputs: // 1 // 2 Case expressions allow for branching based on the record type of a value. rec Foo = [value: String]; rec Bar = []; func printFooBar = [fb: Foo | Bar]: Nil -> case fb of [ Foo: f -> { f.value>>printLine[]; }, Bar: b -> { \"Bar\">>printLine[]; }, ]; printFooBar[Foo[value = \"Foo\"]]; printFooBar[Bar]; // Outputs: // Foo // Bar","title":"Record Unions &amp; Case Expressions"},{"location":"records/#type-parameters","text":"Records may take type parameters rec Pair = \u27e8T\u27e9 => [ first: T, second: T, ]; let point = Pair\u27e8Float\u27e9[first = 1.23, second = 4.5]; point.first>>printLine[]; point.second>>printLine[]; // Outputs: // 1.23 // 4.5","title":"Type parameters"},{"location":"records/#mutability","text":"Records are immutable by default, but a record instance can be made mutable with the mut keyword. The fields of a mutable record can be modified using mut statements. rec Box = [value: Int]; let myBox = mut Box[value = 1]; myBox.value>>printLine[]; mut myBox.value = 2; myBox.value>>printLine[]; // Output // 1 // 2 The mut keyword can also be used in type annotations to require a mutable record. rec Box = [value: Int]; func doubleValue = [box: mut Box]: Nil -> { mut box.value = box.value * 2; }; let myBox = mut Box[value = 4]; myBox.value>>printLine[]; doubleValue[myBox]; myBox.value>>printLine[]; // Outputs: // 4 // 8","title":"Mutability"},{"location":"records/#mutability-parameters","text":"By default, mutability of a record type is propagated to its field types. This is intended to keep simple the common case where a nested record should be deeply mutable or deeply immutable. rec Foo = [a: Bar]; rec Bar = [b: Int]; let mutableFoo = mut Foo[ a = mut Bar[ b = 1 ] ]; mutableFoo.a.b>>printLine[]; mut mutableFoo.a.b = 2; mutableFoo.a.b>>printLine[]; let immutableFooCopy: Foo = mutableFoo; // The following would result in a type error, as immutableFooCopy is deeply immutable // mut immutableFooCopy.a.b = 3; // Outputs: // 1 // 2 However, record field mutability can instead be controlled manually by adding a mutability parameter to a record declaration. If used, the mutability parameter must be the first element of the type parameter list and be prefixed by mut . rec Foo = \u27e8mut M\u27e9 => [ // field a is always immutable a: Bar, // field b is always immutable b: mut Bar, // field c has the same mutability as Foo c: M Bar, ]; rec Bar = [value: Int];","title":"Mutability parameters"},{"location":"type_synonyms/","text":"Type Synonyms Type synonyms allow a custom name to be assigned to a type. type FileName = String; type Extension = String; func printFile = [fileName: FileName, extension: Extension]: Nil -> { (fileName + '.' + extension)>>printLine[]; }; printFile[\"myDoc\", \"txt\"]; // Outputs: // myDoc.txt A type synonym is identical to its value in type checking. Two different synonyms for the same type can be substituted. type Latitude = Float; type Longitude = Float; func printCoordinates = [lat: Latitude, lon: Longitude]: Nil -> { lat>>printLine[]; lon>>printLine[]; }; let currentLat: Latitude = 32.1; let currentLon: Longitude = -0.98; // Oops, reversed the coordinates printCoordinates[currentLon, currentLat]; // Outputs: // -0.98 // 32.1 Type synonyms may have type parameters. type Maybe = \u27e8T\u27e9 => Just\u27e8T\u27e9 | Nothing; rec Just = \u27e8T\u27e9 => [value: T]; rec Nothing = []; func getValueOrDefault = \u27e8T\u27e9 => [maybe: Maybe\u27e8T\u27e9, default: T]: T -> case maybe of [ Just: j -> j.value, Nothing: n -> default, ]; Just\u27e8Bool\u27e9[value = true]>>getValueOrDefault\u27e8Bool\u27e9[false]>>printLine[]; // Outputs: // true Type synonyms may also have mutability parameters. type Tree = \u27e8mut M, T\u27e9 => M Leaf | Node\u27e8T\u27e9; rec Leaf = []; rec Node = \u27e8T\u27e9 => [value: T, left: Tree\u27e8T\u27e9, right: Tree\u27e8T\u27e9]; let mutableTree: mut Tree\u27e8Int\u27e9 = mut Node[ value = 1, left = mut Node[ value = 2, left = Leaf, right = Leaf, ], right = Leaf, ];","title":"Type synonyms"},{"location":"type_synonyms/#type-synonyms","text":"Type synonyms allow a custom name to be assigned to a type. type FileName = String; type Extension = String; func printFile = [fileName: FileName, extension: Extension]: Nil -> { (fileName + '.' + extension)>>printLine[]; }; printFile[\"myDoc\", \"txt\"]; // Outputs: // myDoc.txt A type synonym is identical to its value in type checking. Two different synonyms for the same type can be substituted. type Latitude = Float; type Longitude = Float; func printCoordinates = [lat: Latitude, lon: Longitude]: Nil -> { lat>>printLine[]; lon>>printLine[]; }; let currentLat: Latitude = 32.1; let currentLon: Longitude = -0.98; // Oops, reversed the coordinates printCoordinates[currentLon, currentLat]; // Outputs: // -0.98 // 32.1 Type synonyms may have type parameters. type Maybe = \u27e8T\u27e9 => Just\u27e8T\u27e9 | Nothing; rec Just = \u27e8T\u27e9 => [value: T]; rec Nothing = []; func getValueOrDefault = \u27e8T\u27e9 => [maybe: Maybe\u27e8T\u27e9, default: T]: T -> case maybe of [ Just: j -> j.value, Nothing: n -> default, ]; Just\u27e8Bool\u27e9[value = true]>>getValueOrDefault\u27e8Bool\u27e9[false]>>printLine[]; // Outputs: // true Type synonyms may also have mutability parameters. type Tree = \u27e8mut M, T\u27e9 => M Leaf | Node\u27e8T\u27e9; rec Leaf = []; rec Node = \u27e8T\u27e9 => [value: T, left: Tree\u27e8T\u27e9, right: Tree\u27e8T\u27e9]; let mutableTree: mut Tree\u27e8Int\u27e9 = mut Node[ value = 1, left = mut Node[ value = 2, left = Leaf, right = Leaf, ], right = Leaf, ];","title":"Type Synonyms"},{"location":"variables/","text":"Variables Values can be stored and retrieved later using variables. let foo = 5; foo>>printLine[]; // Ouptuts: // 5 Variable declarations may include type annotations. In many cases, the compiler can infer the type of a variable from its initial value, and the type annotation can be omitted. let bar: Bool = false; bar>>printLine[]; // Ouptuts: // false Mutability Variables are immutable by default but can be declared mutable with a let mut statement. If declared mutable, variables can be mutated later with mut statements. let mut baz = 1; baz>>printLine[]; mut baz = 2; baz>>printLine[]; mut baz = baz * 2; baz>>printLine[]; // Outputs; // 1 // 2 // 4","title":"Variables"},{"location":"variables/#variables","text":"Values can be stored and retrieved later using variables. let foo = 5; foo>>printLine[]; // Ouptuts: // 5 Variable declarations may include type annotations. In many cases, the compiler can infer the type of a variable from its initial value, and the type annotation can be omitted. let bar: Bool = false; bar>>printLine[]; // Ouptuts: // false","title":"Variables"},{"location":"variables/#mutability","text":"Variables are immutable by default but can be declared mutable with a let mut statement. If declared mutable, variables can be mutated later with mut statements. let mut baz = 1; baz>>printLine[]; mut baz = 2; baz>>printLine[]; mut baz = baz * 2; baz>>printLine[]; // Outputs; // 1 // 2 // 4","title":"Mutability"}]}